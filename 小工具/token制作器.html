<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TOKEN制作器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #f0f2f5;
            min-height: 100vh;
            color: #94989f;
            padding: 15px;
            padding-bottom: env(safe-area-inset-bottom, 15px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            padding: clamp(20px, 5vw, 30px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid #e5e7eb;
        }
        
        header {
            text-align: center;
            margin-bottom: clamp(25px, 5vw, 40px);
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        h1 {
            font-size: clamp(1.75rem, 6vw, 2.25rem);
            margin-bottom: 10px;
            color: #111827;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .subtitle {
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            color: #94989f;
            margin-bottom: 20px;
        }
        
        .back-btn {
            display: inline-block;
            background: #f3f4f6;
            color: #94989f;
            padding: 10px 18px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9rem;
            margin-top: 10px;
            border: 1px solid #e5e7eb;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
            color: #111827;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        
        @media (min-width: 992px) {
            .app-container {
                grid-template-columns: 1fr 2fr;
            }
        }
        
        /* 左侧控制面板 */
        .control-panel {
            background: #f9fafb;
            border-radius: 8px;
            padding: 22px;
            border: 1px solid #e5e7eb;
        }
        
        .section-title {
            font-size: 1.15rem;
            margin-bottom: 18px;
            color: #111827;
            font-weight: 600;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title i {
            font-size: 1.1rem;
            color: #2563eb;
        }
        
        /* 边框选择区域 */
        .border-options {
            margin-bottom: 30px;
        }
        
        .border-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .border-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f3f4f6;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            border: 1px solid transparent;
            border-bottom: none;
        }
        
        .border-tab.active {
            background: #fff;
            border-color: #e5e7eb;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
            color: #2563eb;
            font-weight: 500;
        }
        
        .border-tab:hover:not(.active) {
            background: #f9fafb;
        }
        
        .border-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 12px;
            max-height: 300px;
            overflow-y: auto;
            padding: 12px;
            background: #fafafa;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            scrollbar-width: thin;
            scrollbar-color: #d1d5db #f3f4f6;
        }
        
        .border-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .border-list::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 4px;
        }
        
        .border-list::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }
        
        .border-list::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        
        .border-item {
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        
        .border-item:hover, .border-item.selected {
            border-color: #2563eb;
        }
        
        .border-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .border-upload {
            margin-top: 15px;
        }
        
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            background: #fafafa;
        }
        
        .upload-area:hover {
            border-color: #2563eb;
            background: #f9fafb;
        }
        
        .upload-area i {
            font-size: 2rem;
            color: #2563eb;
            margin-bottom: 10px;
        }
        
        .upload-area p {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        /* 立绘上传区域 */
        .character-upload {
            margin-bottom: 30px;
        }
        
        .upload-preview {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .preview-img {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 调整控制区域 */
        .adjust-controls {
            margin-top: 20px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #374151;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #2563eb;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .reset-btn {
            background: #eff6ff;
            color: #2563eb;
            border: 1px solid #dbeafe;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            font-weight: 600;
            margin-top: 5px;
        }
        
        .reset-btn:hover:not(:disabled) {
            background: #dbeafe;
        }
        
        .reset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 橡皮擦控制区域 */
        .eraser-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dbeafe;
        }
        
        .eraser-btn {
            background: #94989f;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .eraser-btn.active {
            background: #2563eb;
        }
        
        .eraser-btn:hover:not(.active):not(:disabled) {
            background: #4b5563;
        }
        
        .eraser-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .eraser-info {
            text-align: center;
            font-size: 0.9rem;
            color: #94989f;
            margin-top: 10px;
            padding: 8px;
            background: #f3f4f6;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        
        .warning-message {
            color: #d97706;
            font-size: 0.85rem;
            margin-top: 5px;
            padding: 5px;
            background: rgba(217, 119, 6, 0.1);
            border-radius: 4px;
            border-left: 3px solid #d97706;
        }
        
        /* 右侧预览和下载区域 */
        .preview-panel {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .canvas-container {
            background: #f9fafb;
            border-radius: 8px;
            padding: 25px;
            border: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-wrapper {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            margin: 0 auto;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        #tokenCanvas {
            width: 100%;
            height: 100%;
            background: #f3f4f6;
            display: block;
            cursor: default;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .canvas-placeholder {
            text-align: center;
            color: #9ca3af;
        }
        
        .canvas-placeholder i {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #d1d5db;
        }
        
        /* 橡皮擦鼠标样式 */
        .eraser-cursor {
            position: absolute;
            pointer-events: none;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
        }
        
        .eraser-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        
        /* 操作按钮区域 */
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .action-btn {
            padding: 15px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .download-btn {
            background: #2563eb;
            color: white;
        }
        
        .download-btn:hover {
            background: #1d4ed8;
        }
        
        .clear-btn {
            background: #94989f;
            color: white;
        }
        
        .clear-btn:hover {
            background: #4b5563;
        }
        
        .action-btn i {
            font-size: 1.1rem;
        }
        
        /* 下载选项 */
        .download-options {
            background: #f9fafb;
            border-radius: 8px;
            padding: 25px;
            border: 1px solid #e5e7eb;
        }
        
        .option-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .option-btn {
            padding: 12px;
            border-radius: 6px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            font-weight: 600;
        }
        
        .option-btn:hover {
            background: #4b5563;
            border-color: #4b5563;
        }
        
        /* 移动端优化 */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
                border-radius: 12px;
            }
            
            .control-panel, .canvas-container, .download-options {
                padding: 20px;
            }
            
            .border-list {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .option-group {
                grid-template-columns: 1fr;
            }
        }
        
        /* 隐藏元素 */
        .hidden {
            display: none;
        }
        
        /* 防止IOS缩放 */
        @supports (-webkit-overflow-scrolling: touch) {
            input, select, textarea {
                font-size: 16px !important;
            }
        }
        
        /* 安全区域适配 */
        @supports (padding: max(0px)) {
            body {
                padding-left: max(15px, env(safe-area-inset-left, 15px));
                padding-right: max(15px, env(safe-area-inset-right, 15px));
                padding-bottom: max(15px, env(safe-area-inset-bottom, 15px));
            }
        }
        
        /* 文件输入隐藏 */
        .file-input {
            display: none;
        }
        
        /* 边框加载状态 */
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.6);
            grid-column: 1 / -1;
        }
        
        .loading-indicator i {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #2563eb;
        }
        
        .empty-message {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            grid-column: 1 / -1;
        }
        
        .empty-message i {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.3);
        }
        
        /* 分页相关样式 */
        .loading-more-indicator {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.6);
            grid-column: 1 / -1;
        }
        
        .loading-more-indicator i {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #2563eb;
        }
        
        .no-more-borders {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            grid-column: 1 / -1;
        }
        
        .no-more-borders i {
            font-size: 1.2rem;
            margin-right: 8px;
            color: #2563eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-user-circle"></i> TOKEN制作器</h1>
            <p class="subtitle">创建个性化角色Token，用于在线跑团游戏</p>
            <a href="../index.html" class="back-btn">
                <i class="fas fa-arrow-left"></i> 返回首页
            </a>
        </header>
        
        <div class="app-container">
            <!-- 左侧控制面板 -->
            <div class="control-panel">
                <!-- 边框选择 -->
                <div class="border-options">
                    <div class="section-title">
                        <i class="fas fa-square"></i> 选择边框
                    </div>
                    
                    <div class="border-tabs">
                        <div class="border-tab active" data-tab="preset">预设边框</div>
                        <div class="border-tab" data-tab="custom">自定义边框</div>
                    </div>
                    
                    <!-- 预设边框列表 -->
                    <div class="border-list" id="presetBorders">
                        <!-- 加载状态 -->
                        <div class="loading-indicator" id="loadingIndicator">
                            <i class="fas fa-spinner fa-spin"></i>
                            <p>正在从 borders 文件夹加载边框...</p>
                        </div>
                        <!-- 预设边框将通过JavaScript动态添加 -->
                    </div>
                    
                    <!-- 自定义边框上传 -->
                    <div class="border-upload hidden" id="customBorderUpload">
                        <div class="upload-area" id="borderUploadArea">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <p>点击上传自定义边框</p>
                            <p>支持PNG、JPG、WebP、SVG格式</p>
                            <p>建议尺寸：500x500像素</p>
                        </div>
                        <input type="file" id="borderFileInput" class="file-input" accept=".png,.jpg,.jpeg,.webp,.svg">
                        
                        <div class="upload-preview hidden" id="customBorderPreview">
                            <img id="customBorderImage" class="preview-img" src="" alt="自定义边框预览">
                            <button class="reset-btn" id="removeCustomBorder">移除自定义边框</button>
                        </div>
                    </div>
                    
                    <!-- 边框透明度控制 -->
                    <div class="control-group" style="margin-top: 20px;">
                        <label class="control-label">边框透明度</label>
                        <div class="slider-container">
                            <input type="range" id="borderOpacitySlider" min="10" max="100" value="70">
                            <span class="slider-value" id="borderOpacityValue">70%</span>
                        </div>
                        <p style="font-size: 0.85rem; color: rgba(255, 255, 255, 0.6); margin-top: 5px;">
                            注：预览时边框透明，下载时不透明
                        </p>
                    </div>
                </div>
                
                <!-- 立绘上传 -->
                <div class="character-upload">
                    <div class="section-title">
                        <i class="fas fa-portrait"></i> 上传角色立绘
                    </div>
                    
                    <div class="upload-area" id="characterUploadArea">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>点击上传角色立绘</p>
                        <p>支持PNG、JPG、WebP格式</p>
                    </div>
                    <input type="file" id="characterFileInput" class="file-input" accept=".png,.jpg,.jpeg,.webp">
                    
                    <div class="upload-preview hidden" id="characterPreview">
                        <img id="characterImage" class="preview-img" src="" alt="角色立绘预览">
                        <button class="reset-btn" id="removeCharacter">移除立绘</button>
                        <div class="warning-message" id="eraserWarning" style="display: none; margin-top: 10px;">
                            <i class="fas fa-exclamation-triangle"></i> 橡皮擦启用中，移除立绘将重置所有擦除内容
                        </div>
                    </div>
                </div>
                
                <!-- 调整控制 -->
                <div class="adjust-controls">
                    <div class="section-title">
                        <i class="fas fa-sliders-h"></i> 调整立绘
                    </div>
                    
                    <div class="warning-message" id="adjustWarning" style="display: none; margin-bottom: 15px;">
                        <i class="fas fa-exclamation-triangle"></i> 橡皮擦启用中，调整立绘将重置所有擦除内容
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">大小调整</label>
                        <div class="slider-container">
                            <input type="range" id="sizeSlider" min="10" max="200" value="100">
                            <span class="slider-value" id="sizeValue">100%</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">水平位置</label>
                        <div class="slider-container">
                            <input type="range" id="positionXSlider" min="-100" max="100" value="0">
                            <span class="slider-value" id="positionXValue">0</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">垂直位置</label>
                        <div class="slider-container">
                            <input type="range" id="positionYSlider" min="-100" max="100" value="0">
                            <span class="slider-value" id="positionYValue">0</span>
                        </div>
                    </div>
                    
                    <button class="reset-btn" id="resetAdjustments">
                        <i class="fas fa-redo"></i> 重置所有调整
                    </button>
                </div>
                
                <!-- 橡皮擦控制 -->
                <div class="eraser-controls">
                    <div class="section-title">
                        <i class="fas fa-eraser"></i> 橡皮擦工具
                    </div>
                    
                    <button class="eraser-btn" id="eraserToggleBtn">
                        <i class="fas fa-eraser"></i> <span id="eraserToggleText">启用橡皮擦</span>
                    </button>
                    
                    <div class="control-group" id="eraserSizeControl">
                        <label class="control-label">橡皮擦大小</label>
                        <div class="slider-container">
                            <input type="range" id="eraserSizeSlider" min="5" max="100" value="30">
                            <span class="slider-value" id="eraserSizeValue">30</span>
                        </div>
                    </div>
                    
                    <button class="reset-btn" id="resetEraserBtn">
                        <i class="fas fa-undo"></i> 恢复被擦除部分
                    </button>
                    
                    <div class="eraser-info">
                        <p><i class="fas fa-info-circle"></i> 在预览区域按住鼠标拖动进行擦除</p>
                        <p style="font-size: 0.8rem; margin-top: 5px;">只擦除立绘，不影响边框</p>
                    </div>
                </div>
            </div>
            
            <!-- 右侧预览和下载区域 -->
            <div class="preview-panel">
                <!-- 画布预览 -->
                <div class="canvas-container">
                    <div class="section-title">
                        <i class="fas fa-eye"></i> 预览效果
                    </div>
                    
                    <div class="canvas-wrapper">
                        <canvas id="tokenCanvas" width="500" height="500"></canvas>
                        <!-- 离屏画布，用于单独处理立绘（以便擦除） -->
                        <canvas id="characterLayer" width="500" height="500" style="display: none;"></canvas>
                        <!-- 离屏画布，用于单独处理边框 -->
                        <canvas id="borderLayer" width="500" height="500" style="display: none;"></canvas>
                        <!-- 橡皮擦鼠标样式 -->
                        <div class="eraser-cursor" id="eraserCursor"></div>
                        <div class="canvas-overlay" id="canvasPlaceholder">
                            <div class="canvas-placeholder">
                                <i class="fas fa-user-circle"></i>
                                <p>上传立绘和边框开始制作</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="action-btn download-btn" id="downloadBtn">
                            <i class="fas fa-download"></i> 下载Token
                        </button>
                        <button class="action-btn clear-btn" id="clearBtn">
                            <i class="fas fa-trash"></i> 清空所有
                        </button>
                    </div>
                </div>
                
                <!-- 下载选项 -->
                <div class="download-options">
                    <div class="section-title">
                        <i class="fas fa-file-download"></i> 下载选项
                    </div>
                    
                    <div class="option-group">
                        <button class="option-btn" data-size="256">256x256 像素</button>
                        <button class="option-btn" data-size="512">512x512 像素</button>
                        <button class="option-btn" data-size="1024">1024x1024 像素</button>
                        <button class="option-btn" data-size="original">原始尺寸</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 应用状态
        const state = {
            selectedBorder: null,
            selectedBorderImage: null, // 存储边框图片对象
            customBorder: null,
            characterImage: null,
            characterScale: 1.0,
            characterX: 0,
            characterY: 0,
            downloadSize: "original",
            presetBorders: [], // 从borders文件夹加载的边框URL列表（只保存路径）
            borderOpacity: 0.7, // 边框透明度，默认70%
            eraserEnabled: false, // 橡皮擦是否启用
            eraserSize: 30, // 橡皮擦大小
            originalCharacterImage: null, // 原始立绘备份（用于恢复被擦除的部分）
            characterData: null, // 存储立绘像素数据，用于橡皮擦
            hasErasure: false, // 标记是否有擦除内容
            
            // 分页相关状态
            currentPage: 1,
            itemsPerPage: 9,
            isLoadingMore: false,
            allBordersLoaded: false,
            
            // 图片缓存
            imageCache: new Map(), // 存储已加载的图片对象
            loadedPages: new Set() // 记录已加载的页码
        };

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 获取DOM元素
            const tokenCanvas = document.getElementById('tokenCanvas');
            const tokenCtx = tokenCanvas.getContext('2d');
            
            // 离屏画布
            const characterCanvas = document.getElementById('characterLayer');
            const characterCtx = characterCanvas.getContext('2d');
            const borderCanvas = document.getElementById('borderLayer');
            const borderCtx = borderCanvas.getContext('2d');
            
            const canvasPlaceholder = document.getElementById('canvasPlaceholder');
            const eraserCursor = document.getElementById('eraserCursor');
            
            // 预设边框列表
            const presetBordersContainer = document.getElementById('presetBorders');
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            // 边框选项卡
            const borderTabs = document.querySelectorAll('.border-tab');
            const presetBordersTab = document.querySelector('.border-tab[data-tab="preset"]');
            const customBordersTab = document.querySelector('.border-tab[data-tab="custom"]');
            const presetBordersSection = document.getElementById('presetBorders');
            const customBorderUploadSection = document.getElementById('customBorderUpload');
            
            // 文件输入
            const borderFileInput = document.getElementById('borderFileInput');
            const characterFileInput = document.getElementById('characterFileInput');
            
            // 按钮和上传区域
            const borderUploadArea = document.getElementById('borderUploadArea');
            const characterUploadArea = document.getElementById('characterUploadArea');
            
            // 预览区域
            const customBorderPreview = document.getElementById('customBorderPreview');
            const customBorderImage = document.getElementById('customBorderImage');
            const characterPreview = document.getElementById('characterPreview');
            const characterImage = document.getElementById('characterImage');
            
            // 警告信息
            const eraserWarning = document.getElementById('eraserWarning');
            const adjustWarning = document.getElementById('adjustWarning');
            
            // 控制滑块
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const positionXSlider = document.getElementById('positionXSlider');
            const positionXValue = document.getElementById('positionXValue');
            const positionYSlider = document.getElementById('positionYSlider');
            const positionYValue = document.getElementById('positionYValue');
            const borderOpacitySlider = document.getElementById('borderOpacitySlider');
            const borderOpacityValue = document.getElementById('borderOpacityValue');
            
            // 橡皮擦控制
            const eraserToggleBtn = document.getElementById('eraserToggleBtn');
            const eraserToggleText = document.getElementById('eraserToggleText');
            const eraserSizeControl = document.getElementById('eraserSizeControl');
            const eraserSizeSlider = document.getElementById('eraserSizeSlider');
            const eraserSizeValue = document.getElementById('eraserSizeValue');
            const resetEraserBtn = document.getElementById('resetEraserBtn');
            
            // 按钮
            const removeCustomBorderBtn = document.getElementById('removeCustomBorder');
            const removeCharacterBtn = document.getElementById('removeCharacter');
            const resetAdjustmentsBtn = document.getElementById('resetAdjustments');
            const downloadBtn = document.getElementById('downloadBtn');
            const clearBtn = document.getElementById('clearBtn');
            const downloadOptions = document.querySelectorAll('.option-btn');
            
            // 从固定目录加载边框文件列表（不加载图片本身）
            async function loadBordersFromFolder() {
                // 固定目录：borders文件夹（与HTML文件同级）
                const borderFolder = 'borders/';
                
                try {
                    // 尝试读取list.txt文件获取边框列表
                    try {
                        const response = await fetch(`${borderFolder}list.txt`);
                        if (response.ok) {
                            const text = await response.text();
                            const fileNames = text.split('\n')
                                .map(line => line.trim())
                                .filter(line => line && !line.startsWith('#'));
                            
                            // 过滤有效的图片文件（添加webp支持）
                            const imageExtensions = ['.png', '.jpg', '.jpeg', '.svg', '.webp'];
                            const validFiles = fileNames.filter(fileName => {
                                const lowerFileName = fileName.toLowerCase();
                                return imageExtensions.some(ext => lowerFileName.endsWith(ext));
                            });
                            
                            if (validFiles.length > 0) {
                                await loadBordersFromList(validFiles, borderFolder);
                                return;
                            }
                        }
                    } catch (e) {
                        console.log('未找到list.txt文件或读取失败，尝试其他方式');
                    }
                    
                    // 如果没有list.txt，尝试加载一些常见的文件名
                    const commonFileNames = [
                        'circle.png', 'square.png', 'hexagon.png', 'shield.png',
                        'star.png', 'simple.png', 'ornate.png', 'combat.png',
                        'border1.png', 'border2.png', 'border3.png', 'border4.png',
                        'frame1.png', 'frame2.png', 'frame3.png', 'frame4.png',
                        'token_frame.png', 'token_border.png'
                    ];
                    
                    await loadBordersFromList(commonFileNames, borderFolder);
                    
                } catch (error) {
                    console.error('加载边框失败:', error);
                    showNoBordersMessage();
                }
            }
            
            // 从文件名列表加载边框（只保存路径，不加载图片）
            async function loadBordersFromList(fileNames, folderPath) {
                const loadedBorders = [];
                
                for (const fileName of fileNames) {
                    try {
                        // 获取显示名称（去掉路径和扩展名）
                        const displayName = fileName
                            .split('/').pop()  // 取最后一部分（文件名）
                            .replace(/\.[^/.]+$/, "");  // 移除扩展名
                        
                        // 设置图片源 - 处理带目录和不带目录的路径
                        let imagePath;
                        if (fileName.includes('/')) {
                            // 如果文件名中已包含路径，直接使用
                            imagePath = `${folderPath}${fileName}`;
                        } else {
                            // 否则拼接路径
                            imagePath = `${folderPath}${fileName}`;
                        }
                        
                        // 只保存图片路径，不创建图片对象
                        loadedBorders.push({
                            name: displayName,  // 显示用名称
                            fileName: fileName, // 原始文件名（带路径）
                            url: imagePath, // 原始URL，用于最终绘制
                            previewUrl: imagePath // 初始使用原始URL，稍后可能替换为压缩版本
                        });
                        
                    } catch (error) {
                        console.log(`添加边框失败: ${fileName}`, error.message);
                    }
                }
                
                if (loadedBorders.length > 0) {
                    state.presetBorders = loadedBorders;
                    renderPresetBorders();
                } else {
                    showNoBordersMessage();
                }
            }
            
            // 加载单个边框图片（按需加载）
            async function loadBorderImage(border, index) {
                // 检查是否已缓存
                if (state.imageCache.has(index)) {
                    return state.imageCache.get(index);
                }
                
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        console.log(`成功加载边框图片: ${border.fileName}`);
                        
                        // 对于非SVG格式的图片，创建压缩预览版本（可选）
                        if (!border.fileName.toLowerCase().endsWith('.svg')) {
                            try {
                                // 创建缩略图预览（可选）
                                createCompressedPreview(img, 80, 80).then(previewUrl => {
                                    border.previewUrl = previewUrl;
                                    state.imageCache.set(index, img);
                                    resolve(img);
                                }).catch(() => {
                                    // 如果压缩失败，使用原图
                                    state.imageCache.set(index, img);
                                    resolve(img);
                                });
                            } catch (e) {
                                console.log('创建压缩预览失败，使用原图:', e.message);
                                state.imageCache.set(index, img);
                                resolve(img);
                            }
                        } else {
                            // SVG格式直接使用
                            state.imageCache.set(index, img);
                            resolve(img);
                        }
                    };
                    
                    img.onerror = () => {
                        console.log(`无法加载边框图片: ${border.fileName}`);
                        reject(new Error(`无法加载图片: ${border.fileName}`));
                    };
                    
                    // 设置超时
                    setTimeout(() => {
                        if (!img.complete) {
                            reject(new Error('加载超时'));
                        }
                    }, 5000);
                    
                    img.src = border.url;
                    img.crossOrigin = "anonymous";
                });
            }
            
            // 创建压缩预览（可选，用于改善性能）
            function createCompressedPreview(img, maxWidth, maxHeight) {
                return new Promise((resolve, reject) => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // 计算缩放比例
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * maxWidth / width);
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * maxHeight / height);
                                height = maxHeight;
                            }
                        }
                        
                        // 设置画布尺寸
                        canvas.width = width;
                        canvas.height = height;
                        
                        // 绘制压缩后的图片
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 转换为低质量JPEG以减小文件大小
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
                        resolve(compressedDataUrl);
                    } catch (error) {
                        reject(error);
                    }
                });
            }
            
            // 显示没有边框的消息
            function showNoBordersMessage() {
                presetBordersContainer.innerHTML = '';
                loadingIndicator.classList.add('hidden');
                
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.innerHTML = `
                    <i class="fas fa-image"></i>
                    <p>未找到边框图片</p>
                    <p style="font-size: 0.9rem; margin-top: 10px;">请在<b>borders</b>文件夹中放置边框图片</p>
                    <p style="font-size: 0.8rem; margin-top: 5px;">支持PNG、JPG、WebP、SVG格式</p>
                `;
                presetBordersContainer.appendChild(emptyMessage);
            }
            
            // 初始化分页功能
            function initPagination() {
                // 监听滚动事件
                presetBordersContainer.addEventListener('scroll', function() {
                    // 检查是否滚动到底部
                    const isAtBottom = this.scrollHeight - this.scrollTop - this.clientHeight < 50;
                    
                    // 如果滚动到底部，并且还有更多边框可加载，并且当前没有正在加载
                    if (isAtBottom && !state.isLoadingMore && !state.allBordersLoaded) {
                        loadNextPage();
                    }
                });
            }
            
            // 加载下一页边框
            function loadNextPage() {
                if (state.isLoadingMore || state.allBordersLoaded) return;
                
                state.isLoadingMore = true;
                state.currentPage++;
                
                // 显示加载指示器
                showLoadingMoreIndicator();
                
                // 模拟加载延迟
                setTimeout(() => {
                    renderPresetBordersPage(state.currentPage);
                    state.isLoadingMore = false;
                }, 300);
            }
            
            // 显示加载更多指示器
            function showLoadingMoreIndicator() {
                // 移除现有的加载指示器（如果有）
                const existingLoader = presetBordersContainer.querySelector('.loading-more-indicator');
                if (existingLoader) {
                    existingLoader.remove();
                }
                
                // 创建加载指示器
                const loader = document.createElement('div');
                loader.className = 'loading-more-indicator';
                loader.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.6);">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>正在加载更多边框...</p>
                    </div>
                `;
                
                presetBordersContainer.appendChild(loader);
            }
            
            // 隐藏加载更多指示器
            function hideLoadingMoreIndicator() {
                const loader = presetBordersContainer.querySelector('.loading-more-indicator');
                if (loader) {
                    loader.remove();
                }
            }
            
            // 渲染指定页面的边框
            function renderPresetBordersPage(page) {
                // 计算开始和结束索引
                const startIndex = (page - 1) * state.itemsPerPage;
                const endIndex = startIndex + state.itemsPerPage;
                
                // 获取当前页的边框
                const pageBorders = state.presetBorders.slice(startIndex, endIndex);
                
                // 如果没有边框了，标记所有边框已加载
                if (pageBorders.length === 0) {
                    state.allBordersLoaded = true;
                    hideLoadingMoreIndicator();
                    
                    // 如果没有更多边框，显示提示
                    if (state.presetBorders.length > 0 && state.currentPage > 1) {
                        const noMoreMessage = document.createElement('div');
                        noMoreMessage.className = 'no-more-borders';
                        noMoreMessage.innerHTML = `
                            <div style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.5); font-style: italic;">
                                <p><i class="fas fa-check-circle"></i> 已加载所有边框</p>
                            </div>
                        `;
                        presetBordersContainer.appendChild(noMoreMessage);
                    }
                    return;
                }
                
                // 隐藏加载指示器
                hideLoadingMoreIndicator();
                
                // 移除"没有更多边框"的消息（如果存在）
                const noMoreMessage = presetBordersContainer.querySelector('.no-more-borders');
                if (noMoreMessage) {
                    noMoreMessage.remove();
                }
                
                // 渲染当前页的边框（异步加载图片）
                renderBorderItems(pageBorders, startIndex, page);
                
                // 如果是第一页，默认选中第一个边框
                if (page === 1 && pageBorders.length > 0) {
                    setTimeout(() => {
                        const firstBorder = presetBordersContainer.querySelector('.border-item');
                        if (firstBorder) {
                            firstBorder.click();
                        }
                    }, 100);
                }
            }
            
            // 渲染边框项目（异步加载图片）
            async function renderBorderItems(borders, startIndex, page) {
                // 标记此页已加载
                state.loadedPages.add(page);
                
                for (let i = 0; i < borders.length; i++) {
                    const border = borders[i];
                    const index = startIndex + i;
                    
                    const borderItem = document.createElement('div');
                    borderItem.className = 'border-item';
                    borderItem.setAttribute('data-index', index);
                    
                    // 创建占位符
                    const placeholder = document.createElement('div');
                    placeholder.className = 'border-item-placeholder';
                    placeholder.style.width = '100%';
                    placeholder.style.height = '100%';
                    placeholder.style.background = 'rgba(50, 50, 80, 0.5)';
                    placeholder.style.display = 'flex';
                    placeholder.style.alignItems = 'center';
                    placeholder.style.justifyContent = 'center';
                    placeholder.innerHTML = `<i class="fas fa-spinner fa-spin" style="color: #2563eb;"></i>`;
                    
                    borderItem.appendChild(placeholder);
                    presetBordersContainer.appendChild(borderItem);
                    
                    // 异步加载图片
                    loadBorderImage(border, index).then(img => {
                        // 图片加载完成后替换占位符
                        const imgElement = document.createElement('img');
                        imgElement.src = border.previewUrl || border.url;
                        imgElement.alt = border.name;
                        imgElement.title = border.name;
                        imgElement.loading = 'lazy';
                        
                        // 替换占位符
                        borderItem.innerHTML = '';
                        borderItem.appendChild(imgElement);
                        
                        // 点击选择边框
                        borderItem.addEventListener('click', function() {
                            selectBorder(index, border);
                        });
                        
                    }).catch(error => {
                        console.log(`边框图片加载失败: ${border.fileName}`, error);
                        // 加载失败时显示错误图标
                        placeholder.innerHTML = `<i class="fas fa-exclamation-triangle" style="color: #e74c3c;"></i>`;
                        placeholder.title = '加载失败';
                        
                        // 即使加载失败，也允许点击（使用原始URL）
                        borderItem.addEventListener('click', function() {
                            selectBorder(index, border);
                        });
                    });
                }
            }
            
            // 选择边框
            function selectBorder(index, border) {
                // 移除其他边框的选中状态
                document.querySelectorAll('.border-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // 选中当前边框
                const borderItem = document.querySelector(`.border-item[data-index="${index}"]`);
                if (borderItem) {
                    borderItem.classList.add('selected');
                }
                
                // 从缓存中获取图片对象，如果没有则加载
                if (state.imageCache.has(index)) {
                    const img = state.imageCache.get(index);
                    state.selectedBorder = border.url;
                    state.selectedBorderImage = img;
                    state.customBorder = null;
                    
                    // 隐藏自定义边框预览
                    customBorderPreview.classList.add('hidden');
                    
                    // 更新画布
                    updateCanvas();
                } else {
                    // 如果图片不在缓存中，加载它
                    loadBorderImage(border, index).then(img => {
                        state.selectedBorder = border.url;
                        state.selectedBorderImage = img;
                        state.customBorder = null;
                        
                        // 隐藏自定义边框预览
                        customBorderPreview.classList.add('hidden');
                        
                        // 更新画布
                        updateCanvas();
                    }).catch(error => {
                        alert(`无法加载边框图片: ${border.name}`);
                    });
                }
            }
            
            // 渲染预设边框
            function renderPresetBorders() {
                // 清空容器（保留加载指示器）
                const itemsToRemove = presetBordersContainer.querySelectorAll('.border-item, .empty-message, .no-more-borders, .loading-more-indicator');
                itemsToRemove.forEach(item => item.remove());
                
                // 隐藏加载指示器
                loadingIndicator.classList.add('hidden');
                
                // 如果没有边框，显示提示
                if (state.presetBorders.length === 0) {
                    showNoBordersMessage();
                    return;
                }
                
                // 重置分页状态
                state.currentPage = 1;
                state.allBordersLoaded = false;
                state.loadedPages.clear();
                
                // 渲染第一页
                renderPresetBordersPage(1);
            }
            
            // 初始化画布
            function initCanvas() {
                updateCanvas();
            }
            
            // 更新画布（只更新边框透明度，不影响立绘）
            function updateCanvas() {
                // 检查是否有内容
                const hasContent = state.characterImage || state.selectedBorderImage || state.customBorder;
                
                if (!hasContent) {
                    canvasPlaceholder.classList.remove('hidden');
                    // 清空所有画布
                    tokenCtx.clearRect(0, 0, tokenCanvas.width, tokenCanvas.height);
                    characterCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                    borderCtx.clearRect(0, 0, borderCanvas.width, borderCanvas.height);
                    return;
                }
                
                canvasPlaceholder.classList.add('hidden');
                
                // 绘制边框到borderCanvas（应用透明度）
                if (state.customBorder || state.selectedBorderImage) {
                    drawBorder();
                }
                
                // 将两个图层合并到tokenCanvas
                composeCanvas();
            }
            
            // 绘制角色立绘（用于调整大小位置或重新绘制时）
            function drawCharacter() {
                if (!state.characterImage) return;
                
                // 清空角色画布
                characterCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                
                const canvasWidth = characterCanvas.width;
                const canvasHeight = characterCanvas.height;
                
                // 计算立绘尺寸和位置
                const scale = state.characterScale;
                const imgWidth = state.characterImage.width * scale;
                const imgHeight = state.characterImage.height * scale;
                
                // 计算中心点偏移
                const offsetX = (canvasWidth - imgWidth) / 2;
                const offsetY = (canvasHeight - imgHeight) / 2;
                
                // 应用用户调整的位置
                const x = offsetX + (state.characterX / 100) * canvasWidth;
                const y = offsetY + (state.characterY / 100) * canvasHeight;
                
                // 保存原始图像用于橡皮擦恢复
                if (!state.originalCharacterImage) {
                    state.originalCharacterImage = new Image();
                    state.originalCharacterImage.src = state.characterImage.src;
                }
                
                // 绘制立绘
                characterCtx.drawImage(state.characterImage, x, y, imgWidth, imgHeight);
                
                // 保存像素数据用于橡皮擦
                saveCharacterData();
                state.hasErasure = false; // 重置擦除标记
                
                // 更新显示画布
                composeCanvas();
            }
            
            // 保存立绘像素数据
            function saveCharacterData() {
                state.characterData = characterCtx.getImageData(0, 0, characterCanvas.width, characterCanvas.height);
            }
            
            // 绘制边框
            function drawBorder() {
                // 清空边框画布
                borderCtx.clearRect(0, 0, borderCanvas.width, borderCanvas.height);
                
                // 设置边框透明度
                borderCtx.globalAlpha = state.borderOpacity;
                
                if (state.customBorder) {
                    // 绘制自定义边框
                    borderCtx.drawImage(state.customBorder, 0, 0, borderCanvas.width, borderCanvas.height);
                } else if (state.selectedBorderImage) {
                    // 绘制预设边框
                    borderCtx.drawImage(state.selectedBorderImage, 0, 0, borderCanvas.width, borderCanvas.height);
                }
                
                // 重置透明度
                borderCtx.globalAlpha = 1.0;
            }
            
            // 合并两个图层到显示画布
            function composeCanvas() {
                // 清空显示画布
                tokenCtx.clearRect(0, 0, tokenCanvas.width, tokenCanvas.height);
                
                // 先绘制角色图层
                tokenCtx.drawImage(characterCanvas, 0, 0);
                // 再绘制边框图层（带透明度）
                tokenCtx.globalAlpha = state.borderOpacity;
                tokenCtx.drawImage(borderCanvas, 0, 0);
                tokenCtx.globalAlpha = 1.0;
            }
            
            // 更新橡皮擦鼠标样式
            function updateEraserCursor() {
                const size = state.eraserSize;
                eraserCursor.style.width = size + 'px';
                eraserCursor.style.height = size + 'px';
                eraserCursor.style.borderWidth = Math.max(2, size / 15) + 'px';
            }
            
            // 显示橡皮擦鼠标样式
            function showEraserCursor(x, y) {
                const rect = tokenCanvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;
                
                eraserCursor.style.left = (canvasX - state.eraserSize / 2) + 'px';
                eraserCursor.style.top = (canvasY - state.eraserSize / 2) + 'px';
                eraserCursor.style.display = 'block';
            }
            
            // 隐藏橡皮擦鼠标样式
            function hideEraserCursor() {
                eraserCursor.style.display = 'none';
            }
            
            // 锁定/解锁立绘相关控件
            function toggleCharacterControls(locked) {
                // 移除立绘按钮
                removeCharacterBtn.disabled = locked;
                
                // 调整立绘滑块
                sizeSlider.disabled = locked;
                positionXSlider.disabled = locked;
                positionYSlider.disabled = locked;
                
                // 重置调整按钮
                resetAdjustmentsBtn.disabled = locked;
                
                // 显示/隐藏警告信息
                eraserWarning.style.display = locked ? 'block' : 'none';
                adjustWarning.style.display = locked ? 'block' : 'none';
            }
            
            // 检查并处理橡皮擦内容重置
            function checkAndResetErasure(actionName, callback) {
                if (state.eraserEnabled && state.hasErasure) {
                    if (confirm(`橡皮擦已启用且已有擦除内容，${actionName}将重置所有擦除内容。确定要继续吗？`)) {
                        // 禁用橡皮擦
                        disableEraser();
                        // 执行回调函数
                        callback();
                    }
                } else {
                    // 如果没有启用橡皮擦或没有擦除内容，直接执行回调
                    callback();
                }
            }
            
            // 禁用橡皮擦
            function disableEraser() {
                state.eraserEnabled = false;
                eraserToggleBtn.classList.remove('active');
                eraserToggleText.textContent = '启用橡皮擦';
                tokenCanvas.style.cursor = 'default';
                hideEraserCursor();
                toggleCharacterControls(false);
            }
            
            // 切换边框选项卡
            borderTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabType = this.getAttribute('data-tab');
                    
                    // 更新选项卡状态
                    borderTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 显示对应的内容
                    if (tabType === 'preset') {
                        presetBordersSection.classList.remove('hidden');
                        customBorderUploadSection.classList.add('hidden');
                    } else if (tabType === 'custom') {
                        presetBordersSection.classList.add('hidden');
                        customBorderUploadSection.classList.remove('hidden');
                        
                        // 取消选中预设边框
                        document.querySelectorAll('.border-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        
                        state.selectedBorder = null;
                        state.selectedBorderImage = null;
                    }
                });
            });
            
            // 边框上传（支持WebP）
            borderUploadArea.addEventListener('click', function() {
                borderFileInput.click();
            });
            
            borderFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // 检查文件类型（添加WebP支持）
                const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'];
                if (!validTypes.includes(file.type)) {
                    alert('请上传PNG、JPG、WebP或SVG格式的图片');
                    return;
                }
                
                // 创建图片对象
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    img.src = event.target.result;
                    img.onload = function() {
                        // 更新状态
                        state.customBorder = img;
                        state.selectedBorder = null;
                        state.selectedBorderImage = null;
                        
                        // 显示预览并隐藏上传区域
                        customBorderImage.src = img.src;
                        customBorderPreview.classList.remove('hidden');
                        borderUploadArea.classList.add('hidden');
                        
                        // 更新画布
                        updateCanvas();
                    };
                };
                
                reader.readAsDataURL(file);
            });
            
            // 移除自定义边框
            removeCustomBorderBtn.addEventListener('click', function() {
                state.customBorder = null;
                customBorderPreview.classList.add('hidden');
                borderUploadArea.classList.remove('hidden');
                borderFileInput.value = '';
                
                // 切换回预设边框选项卡
                presetBordersTab.click();
                
                // 更新画布
                updateCanvas();
            });
            
            // 角色立绘上传（支持WebP）
            characterUploadArea.addEventListener('click', function() {
                characterFileInput.click();
            });
            
            characterFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // 检查文件类型（添加WebP支持）
                const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp'];
                if (!validTypes.includes(file.type)) {
                    alert('请上传PNG、JPG或WebP格式的图片');
                    return;
                }
                
                // 创建图片对象
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    img.src = event.target.result;
                    img.onload = function() {
                        checkAndResetErasure('上传新立绘', function() {
                            // 更新状态
                            state.characterImage = img;
                            state.originalCharacterImage = null; // 重置原始图像
                            state.characterData = null; // 重置像素数据
                            state.hasErasure = false; // 重置擦除标记
                            
                            // 显示预览并隐藏上传区域
                            characterImage.src = img.src;
                            characterPreview.classList.remove('hidden');
                            characterUploadArea.classList.add('hidden');
                            
                            // 重置滑块值
                            sizeSlider.value = 100;
                            state.characterScale = 1.0;
                            sizeValue.textContent = '100%';
                            
                            positionXSlider.value = 0;
                            state.characterX = 0;
                            positionXValue.textContent = '0';
                            
                            positionYSlider.value = 0;
                            state.characterY = 0;
                            positionYValue.textContent = '0';
                            
                            // 绘制立绘到预览区域
                            drawCharacter();
                        });
                    };
                };
                
                reader.readAsDataURL(file);
            });
            
            // 移除角色立绘
            removeCharacterBtn.addEventListener('click', function() {
                checkAndResetErasure('移除立绘', function() {
                    state.characterImage = null;
                    state.originalCharacterImage = null;
                    state.characterData = null;
                    state.hasErasure = false;
                    characterPreview.classList.add('hidden');
                    characterUploadArea.classList.remove('hidden');
                    characterFileInput.value = '';
                    
                    // 清空角色画布
                    characterCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                    
                    // 更新画布
                    updateCanvas();
                });
            });
            
            // 调整滑块事件
            sizeSlider.addEventListener('input', function() {
                checkAndResetErasure('调整立绘大小', function() {
                    state.characterScale = this.value / 100;
                    sizeValue.textContent = this.value + '%';
                    drawCharacter();
                }.bind(this));
            });
            
            positionXSlider.addEventListener('input', function() {
                checkAndResetErasure('调整立绘位置', function() {
                    state.characterX = parseInt(this.value);
                    positionXValue.textContent = this.value;
                    drawCharacter();
                }.bind(this));
            });
            
            positionYSlider.addEventListener('input', function() {
                checkAndResetErasure('调整立绘位置', function() {
                    state.characterY = parseInt(this.value);
                    positionYValue.textContent = this.value;
                    drawCharacter();
                }.bind(this));
            });
            
            // 边框透明度滑块 - 不重置立绘和擦除
            borderOpacitySlider.addEventListener('input', function() {
                state.borderOpacity = this.value / 100;
                borderOpacityValue.textContent = this.value + '%';
                // 只更新边框，不影响立绘和擦除
                drawBorder();
                composeCanvas();
            });
            
            // 橡皮擦大小滑块
            eraserSizeSlider.addEventListener('input', function() {
                state.eraserSize = parseInt(this.value);
                eraserSizeValue.textContent = this.value;
                updateEraserCursor();
            });
            
            // 重置所有调整
            resetAdjustmentsBtn.addEventListener('click', function() {
                checkAndResetErasure('重置立绘调整', function() {
                    sizeSlider.value = 100;
                    state.characterScale = 1.0;
                    sizeValue.textContent = '100%';
                    
                    positionXSlider.value = 0;
                    state.characterX = 0;
                    positionXValue.textContent = '0';
                    
                    positionYSlider.value = 0;
                    state.characterY = 0;
                    positionYValue.textContent = '0';
                    
                    drawCharacter();
                });
            });
            
            // 切换橡皮擦模式
            eraserToggleBtn.addEventListener('click', function() {
                if (state.eraserEnabled) {
                    disableEraser();
                } else {
                    // 确保有立绘可以擦除
                    if (!state.characterImage) {
                        alert('请先上传角色立绘才能使用橡皮擦功能');
                        return;
                    }
                    
                    state.eraserEnabled = true;
                    this.classList.add('active');
                    eraserToggleText.textContent = '禁用橡皮擦';
                    tokenCanvas.style.cursor = 'none';
                    
                    // 保存原始像素数据
                    if (state.characterData === null) {
                        saveCharacterData();
                    }
                    
                    // 初始化橡皮擦鼠标样式
                    updateEraserCursor();
                    
                    // 锁定立绘相关控件
                    toggleCharacterControls(true);
                }
            });
            
            // 恢复被擦除的部分
            resetEraserBtn.addEventListener('click', function() {
                if (state.characterData) {
                    // 将保存的原始像素数据放回characterCanvas
                    characterCtx.putImageData(state.characterData, 0, 0);
                    state.hasErasure = false;
                    composeCanvas();
                }
            });
            
            // 橡皮擦擦除功能
            let isErasing = false;
            
            // 鼠标移动时更新橡皮擦鼠标样式位置
            tokenCanvas.addEventListener('mousemove', function(e) {
                if (state.eraserEnabled) {
                    showEraserCursor(e.clientX, e.clientY);
                }
            });
            
            tokenCanvas.addEventListener('mouseenter', function(e) {
                if (state.eraserEnabled) {
                    showEraserCursor(e.clientX, e.clientY);
                }
            });
            
            tokenCanvas.addEventListener('mouseleave', function() {
                if (state.eraserEnabled) {
                    hideEraserCursor();
                }
                isErasing = false;
            });
            
            tokenCanvas.addEventListener('mousedown', function(e) {
                if (state.eraserEnabled && state.characterImage) {
                    isErasing = true;
                    erase(e.clientX, e.clientY);
                }
            });
            
            tokenCanvas.addEventListener('mousemove', function(e) {
                if (isErasing && state.eraserEnabled && state.characterImage) {
                    erase(e.clientX, e.clientY);
                }
            });
            
            tokenCanvas.addEventListener('mouseup', function() {
                isErasing = false;
            });
            
            // 触摸屏支持
            tokenCanvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (state.eraserEnabled && state.characterImage) {
                    isErasing = true;
                    const touch = e.touches[0];
                    erase(touch.clientX, touch.clientY);
                }
            });
            
            tokenCanvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (isErasing && state.eraserEnabled && state.characterImage) {
                    const touch = e.touches[0];
                    erase(touch.clientX, touch.clientY);
                }
            });
            
            tokenCanvas.addEventListener('touchend', function() {
                isErasing = false;
            });
            
            function erase(clientX, clientY) {
                const rect = tokenCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                // 将画布坐标转换为characterCanvas坐标
                const scaleX = tokenCanvas.width / rect.width;
                const scaleY = tokenCanvas.height / rect.height;
                const canvasX = x * scaleX;
                const canvasY = y * scaleY;
                
                // 使用橡皮擦擦除（在characterCanvas上）
                // 使用destination-out合成模式实现擦除效果
                characterCtx.save();
                characterCtx.globalCompositeOperation = 'destination-out';
                characterCtx.beginPath();
                characterCtx.arc(canvasX, canvasY, state.eraserSize / 2, 0, Math.PI * 2);
                characterCtx.fill();
                characterCtx.restore();
                
                // 标记有擦除内容
                state.hasErasure = true;
                
                // 更新显示画布
                composeCanvas();
            }
            
            // 下载Token
            function downloadToken(size = "original") {
                // 检查是否有内容
                if (!state.selectedBorder && !state.customBorder && !state.characterImage) {
                    alert('请先添加边框或立绘');
                    return;
                }
                
                // 创建临时画布
                let downloadCanvas, downloadCtx;
                
                if (size === "original") {
                    downloadCanvas = document.createElement('canvas');
                    downloadCanvas.width = tokenCanvas.width;
                    downloadCanvas.height = tokenCanvas.height;
                    downloadCtx = downloadCanvas.getContext('2d');
                } else {
                    const sizeNum = parseInt(size);
                    downloadCanvas = document.createElement('canvas');
                    downloadCanvas.width = sizeNum;
                    downloadCanvas.height = sizeNum;
                    downloadCtx = downloadCanvas.getContext('2d');
                }
                
                // 清空为透明
                downloadCtx.clearRect(0, 0, downloadCanvas.width, downloadCanvas.height);
                
                // 先绘制角色立绘（从characterCanvas获取，包含擦除效果）
                if (state.characterImage) {
                    // 计算缩放比例
                    const scaleX = downloadCanvas.width / characterCanvas.width;
                    const scaleY = downloadCanvas.height / characterCanvas.height;
                    
                    downloadCtx.save();
                    downloadCtx.scale(scaleX, scaleY);
                    downloadCtx.drawImage(characterCanvas, 0, 0);
                    downloadCtx.restore();
                }
                
                // 后绘制边框（下载时不透明）
                downloadCtx.globalAlpha = 1.0; // 确保边框不透明
                if (state.customBorder) {
                    downloadCtx.drawImage(state.customBorder, 0, 0, downloadCanvas.width, downloadCanvas.height);
                } else if (state.selectedBorderImage) {
                    downloadCtx.drawImage(state.selectedBorderImage, 0, 0, downloadCanvas.width, downloadCanvas.height);
                }
                
                // 触发下载
                triggerDownload(downloadCanvas);
            }
            
            // 触发下载
            function triggerDownload(canvas) {
                // 创建下载链接
                const link = document.createElement('a');
                link.download = `trpg-token-${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            // 下载按钮事件
            downloadBtn.addEventListener('click', function() {
                downloadToken(state.downloadSize);
            });
            
            // 下载选项选择
            downloadOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // 更新选中的选项样式
                    downloadOptions.forEach(opt => {
                        opt.style.background = '#94989f';
                        opt.style.borderColor = '#94989f';
                        opt.style.color = 'white';
                    });
                    
                    this.style.background = '#2563eb';
                    this.style.borderColor = '#2563eb';
                    this.style.color = 'white';
                    
                    // 更新下载尺寸
                    state.downloadSize = this.getAttribute('data-size');
                });
            });
            
            // 默认选中第一个下载选项
            if (downloadOptions.length > 0) {
                downloadOptions[0].click();
            }
            
            // 清空所有
            clearBtn.addEventListener('click', function() {
                if (confirm('确定要清空所有内容吗？这将移除边框、立绘和所有编辑。')) {
                    // 重置状态
                    state.selectedBorder = null;
                    state.selectedBorderImage = null;
                    state.customBorder = null;
                    state.characterImage = null;
                    state.originalCharacterImage = null;
                    state.characterData = null;
                    state.hasErasure = false;
                    
                    // 重置UI
                    document.querySelectorAll('.border-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    customBorderPreview.classList.add('hidden');
                    characterPreview.classList.add('hidden');
                    
                    borderUploadArea.classList.remove('hidden');
                    characterUploadArea.classList.remove('hidden');
                    
                    borderFileInput.value = '';
                    characterFileInput.value = '';
                    
                    // 切换回预设边框选项卡
                    presetBordersTab.click();
                    
                    // 重置调整
                    sizeSlider.value = 100;
                    sizeValue.textContent = '100%';
                    positionXSlider.value = 0;
                    positionXValue.textContent = '0';
                    positionYSlider.value = 0;
                    positionYValue.textContent = '0';
                    
                    // 重置橡皮擦
                    if (state.eraserEnabled) {
                        disableEraser();
                    }
                    
                    // 清空所有画布
                    tokenCtx.clearRect(0, 0, tokenCanvas.width, tokenCanvas.height);
                    characterCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                    borderCtx.clearRect(0, 0, borderCanvas.width, borderCanvas.height);
                    
                    // 显示占位符
                    canvasPlaceholder.classList.remove('hidden');
                }
            });
            
            // 初始化
            loadBordersFromFolder().then(() => {
                initPagination();
                initCanvas();
            });
            
            // 移动端优化：防止双击缩放
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        });
    </script>
</body>
</html>